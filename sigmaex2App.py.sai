import ast
import urllib
import urllib2
import logging
import requests
import yaml
from botocore import regions
from flask import Flask, render_template, url_for, request, json, flash, jsonify
import flask.ext.login
from flask_httpauth import HTTPBasicAuth
from flask import make_response
from flask_login import LoginManager, login_user, logout_user, current_user, login_required, login_manager
#from dockerregistry import dockerregistry
from sigmaex2classes import dockerregistry
#from dockerswarm import SwarmClient
from sigmaex2classes import SwarmClient
from werkzeug.utils import redirect
from models import mysql, validate, putawsconfigdata, getawsconfigdata, putregistrydata, getregistrydata, registryhost, \
    putservicedata, getregistrydetails, getservicedata, getdockerswarmdata, getswarmdict, getdashboardData, \
    deleteservicedata, deleteswarmdata, getviewswarmdetails
#from utils import get_log_level, sortdictolist
from sigmaex2classes import sortdictolist
from utils import runBackgroundJobs, tick, registrylist
from sigmaex2classes import StackClient, AWSClient

instancetype = []

app = Flask(__name__)
app.config.from_object('config')

# Final version we need to create a database object so we don't need to read the app.conf again the models.py
# We need to fix this later after demo
_sessiondata,_sessioncolumns = getawsconfigdata ( )
_awsclient = AWSClient(_sessiondata[0]['AWS_ACCESS_KEY_ID'],_sessiondata[0]['AWS_SECRET_ACCESS_KEY'], _sessiondata[0]['AWS_REGION_NAME'])
app.config.update(_sessiondata[0])
print app.config
# After login we need to make sure app.config.AWSClient context is saved
mysql.init_app(app)

#runBackgroundJobs(dashboardData={'awsaccount': 3, 'dockerswarms': 5, 'containers': 5, 'services': 10})

## Route to any template
@app.route('/',  methods=['GET', 'POST'])
def login():
    error = None
    if request.method == 'POST':
        username = request.form['username']
        print username
        password = request.form['password']
        completion = validate(username, password)
        if completion ==False:
            error = 'Invalid Credentials. Please try again.'
        else:
            return redirect(url_for('dashboard'))

    return render_template('login.html', error=error)

@app.route('/dashboard')
def dashboard():
    SwarmName='docker5'
    SwarmURL=_awsclient.getmanagerip(SwarmName) + ":3000"

    #dashboardData = {'awsaccount': getaccountcount(), 'dockerswarms': 5 'containers': 5, 'services': 10}
    dashboardData = getdashboardData()
    return render_template('index.html',SwarmURL=SwarmURL,dashboardData=dashboardData)

@app.route('/awssettings',methods=['GET', 'POST'])
def awssettings():
    regions = ['ap-south-1', 'eu-west-3', 'eu-west-2', 'eu-west-1', 'ap-northeast-2', 'ap-northeast-1', 'sa-east-1',
               'ca-central-1', 'ap-southeast-1', 'ap-south', 'east-2', 'eu-central-1', 'us-east-1', 'us-east-2',
               'us-west-1', 'us-west-2']
    if request.method == 'POST':
        AccessKey = request.form['AccessKey']
        SeceretKey = request.form['SeceretKey']
        Region = request.form['Region']
        AWSAccountID = request.form['AWSAccountID']
        putawsconfigdata(AccessKey, SeceretKey, Region, AWSAccountID)
        awsconfigdata, awsconfigcolumns = getawsconfigdata()
        return render_template('awssettingstable.html', data=awsconfigdata, columns=awsconfigcolumns,
                               title='AWS Settings Table')
    return render_template('awssettings.html',names=regions)


@app.route('/awssettingstable',methods=['GET', 'POST'])
def awssettingstable():
    datadict, dbcolumns = getawsconfigdata()
    dbdata=sortdictolist(datadict,dbcolumns)
    return render_template('table_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title='AWS Settings Table')

@app.route('/table_template',methods=['GET', 'POST'])
def table_template():
    datadict, dbcolumns = getawsconfigdata()
    dbdata=sortdictolist(datadict,dbcolumns)
    return render_template('table_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="Table Template")

@app.route('/registrysettings',methods=['GET', 'POST'])
def registrysettings():
    if request.method == 'POST':
        Registry = request.form['Registry']
        RegistryUsername = request.form['RegistryUsername']
        RegistryPassword = request.form['RegistryPassword']
        putregistrydata(Registry,  RegistryUsername, RegistryPassword)
        datadict, dbcolumns = getregistrydata()
        dbdata=sortdictolist(datadict,dbcolumns)
        return render_template('table_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="Registry Details")
    return render_template('registrysettings.html')

@app.route('/registrysettingstable',methods=['GET', 'POST'])
def registrysettingstable():
    datadict, dbcolumns = getregistrydata()
    dbdata=sortdictolist(datadict,dbcolumns)
    return render_template('table_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="Registry Details")

@app.route('/listimages',methods=['GET', 'POST'])
def listimages():
    reg = dockerregistry(app.config["REGISTRY_URL"])
    imagedata=reg.registry_list()
    #print imagedata
    dbcolumns= [
        {
            "field": "tag",
            "title": "tag",
            "sortable": True,
        },
        {
            "field": "image_name",
            "title": "image_name",
            "sortable": True,
        }
    ]
    imagedatalist=[]
    temp={}
    for k,v in imagedata.items():
        #print str(k)
        for lv in v:
            #print " ---" + str(lv)
            temp['image_name']=str(k)
            temp['tag']=str(lv)
            imagedatalist.append(temp)
            temp={}
    dbdata = sortdictolist(imagedatalist,dbcolumns)
    return render_template('image_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title='Images Table')

@app.route('/createservice',methods=['GET', 'POST'])
def createservice():
    host=registryhost()
    print host
    if request.method == 'POST':
        SwarmName=request.form['SwarmName']
        SwarmURL=_awsclient.getmanagerip(request.form['SwarmName']) + ":2375"
        print SwarmURL
        #SwarmURL='54.245.31.33:2375'
        ServiceName = request.form['ServiceName']
        print ServiceName
        ImageName = request.form['ImageName']
        print "ImageName " + ImageName
        HostPort = int(request.form['HostPort'])
        print HostPort
        ContainerPort = int(request.form['ContainerPort'])
        print ContainerPort
        DockerRegistry = request.form['DockerRegistry']
        print DockerRegistry
        Replicas = int(request.form['Replicas'])
        print Replicas
        #Command = request.form['ContainerPort']

        servicecolumns = [
            { "field": "SwarmName", "title": "SwarmName", "sortable": True,},
            { "field": "SwarmURL", "title": "SwarmURL", "sortable": True, },
            { "field": "ServiceName", "title": "ServiceName", "sortable": True,},
            { "field": "ImageName", "title": "ImageName", "sortable": True,},
            { "field": "HostPort", "title": "HostPort", "sortable": True,},
            { "field": "ContainerPort", "title": "ContainerPort", "sortable": True,},
            { "field": "DockerRegistry", "title": "DockerRegistry", "sortable": True,},
            { "field": "Replicas", "title": "Replicas", "sortable": True}
        ]

        putservicedata(SwarmName,SwarmURL,ServiceName,ImageName,HostPort,ContainerPort,DockerRegistry,Replicas)
        registry_username,registry_password=getregistrydetails(DockerRegistry)
        sc = SwarmClient(dockerhost=SwarmURL,username=registry_username,password=registry_password,registry=DockerRegistry)
        sc.createservice(service_name=ServiceName,host_port=HostPort,container_port=ContainerPort,image=DockerRegistry+"/"+ImageName,command=None,replicas=Replicas)
        datadict, dbcolumns = getservicedata()
        dbdata=sortdictolist(datadict,dbcolumns)
        print dbdata
        return render_template('service_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="Service Details")
    return render_template('createservice.html',names=host)



@app.route('/viewservices',methods=['GET', 'POST'])
def viewservices():
    datadict, dbcolumns = getservicedata()
    #print datadict
    dbdata=sortdictolist(datadict,dbcolumns)
    print "saikiran"
    print dbdata
    return render_template('service_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="Service Details")

@app.route('/deleteservice',methods=['POST'])
def deleteservice():
    serviceList = request.get_json()
    print serviceList
    print type(serviceList)
    # Based on these values we will delete backend database rows..
    for service in serviceList:
        deleteservicedata(service)

    datadict, dbcolumns = getservicedata()
    #datadict, dbcolumns = getdockerswarmdata()
    dbdata=sortdictolist(datadict,dbcolumns)
    #return render_template('table_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="DockerSwarm Clusters")
    return render_template('service_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="DockerSwarm Clusters")

# PENDING
@app.route('/viewservicedtails')
def viewservicedtails():
    return render_template('viewservicedetails.html')

@app.route('/createdockerswarm',methods=['GET', 'POST'])
def createdockerswarm():
    if request.method == 'POST':
        SwarmName = request.form['SwarmName']
        KeyName = request.form['KeyName']
        EnableCloudWatchLogs = 'yes'
        EnableSystemPrune = 'no'
        ManagerInstanceType = request.form['ManagerInstanceType']
        ManagerSize = request.form['ManagerSize']
        ManagerDiskType = request.form['ManagerDiskType']
        ManagerDiskSize = request.form['ManagerDiskSize']
        InstanceType = request.form['InstanceType']
        ClusterSize = request.form['ClusterSize']
        WorkerDiskType = request.form['WorkerDiskType']
        WorkerDiskSize = request.form['WorkerDiskSize']

        payload = {
            #"SwarmName" : str(SwarmName),
            "KeyName" : str(KeyName) ,
            "EnableCloudWatchLogs" : str(EnableCloudWatchLogs),
            "EnableSystemPrune": str(EnableSystemPrune),
            "ManagerInstanceType" :str(ManagerInstanceType),
            "ManagerSize" :str(ManagerSize),
            "ManagerDiskType": str(ManagerDiskType),
            "ManagerDiskSize":str(ManagerDiskSize),
            "InstanceType" :str(InstanceType),
            "ClusterSize" : str(ClusterSize),
            "WorkerDiskType" :str(WorkerDiskType),
            "WorkerDiskSize" :str(WorkerDiskSize),
        }

        sc=StackClient(app,_awsclient,str(SwarmName))
        sc.createstack(payload)
        #putdockerswarmdata(**args)

        datadict, dbcolumns = getdockerswarmdata()
        dbdata=sortdictolist(datadict,dbcolumns)
        #return render_template('table_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="DockerSwarm Details")
        #return render_template('viewdockerswarm.html',dbdata=dbdata,dbcolumns=dbcolumns,title="DockerSwarm Details")
        return render_template('dockerswarm_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="DockerSwarm Details")
    return render_template('dockerswarm.html')

@app.route('/viewdockerswarm',methods=['GET', 'POST'])
def viewdockerswarm():
    datadict, dbcolumns = getdockerswarmdata()
    dbdata=sortdictolist(datadict,dbcolumns)
    return render_template('dockerswarm_template.html',dbdata=dbdata,dbcolumns=dbcolumns,title="DockerSwarm Clusters")

@app.route('/viewswarmdetails',methods=['GET','POST'])
def viewswarmdetails():
    SwarmName = request.get_json()
    dbdata = sortdictolist(Swarmdata_info, Swarm_info)
    #print "This request coming form post",SwarmName

    mangerserverdetails = [{u'Hostname': 'localhost', u'Address': '127.0.0.1', u'Engine Version': '1.0',u'Availability': 'Active',u'State': 'ready'}]
    workerserverdetails = [{u'Hostname': 'localhost', u'Address': '127.0.0.1', u'Engine Version': '1.0',u'Availability': 'Active',u'State': 'ready'}]

    Swarmdata_info, Swarm_mangerdata_info, Swarm_workerdata_info, Swarm_info, Swarm_Manager,Swarm_Worker = getviewswarmdetails()
    #################################################

    #####################################################
    swarmmangerdata = sortdictolist(Swarm_mangerdata_info, Swarm_Manager)

    Manger_server = [
        {"field": "Hostname", "title": "Hostname", "sortable": True},
        {"field": "Address", "title": "Address", "sortable": True},
        {"field": "Engine Version", "title": "Engine Version", "sortable": True},
        {"field": "Availability", "title": "Availability", "sortable": True},
        {"field": "State", "title": "State", "sortable": True}
    ]


    Worker_server = [
        {"field": "Hostname", "title": "Hostname", "sortable": True},
        {"field": "Address", "title": "Address", "sortable": True},
        {"field": "Engine Version", "title": "Engine Version", "sortable": True},
        {"field": "Availability", "title": "Availability", "sortable": True},
        {"field": "State", "title": "State", "sortable": True}
    ]

    manager = sortdictolist(mangerserverdetails, Manger_server)
    worker = sortdictolist(workerserverdetails, Worker_server)

    #####################################################
    swarmworkerdata = sortdictolist(Swarm_workerdata_info, Swarm_Worker)
    workerserverdetails = [{u'Hostname': 'localhost', u'Address': '127.0.0.1', u'Engine Version': '1.0',u'Availability': 'Active',u'State': 'ready'}]

    return render_template('viewswarmdetails.html',Swarmdata_info=dbdata, Swarm_mangerdata_info=swarmmangerdata, Swarm_workerdata_info=swarmworkerdata,mangerserverdetails=manager,Manger_server=Manger_server,workerserverdetails=worker,Worker_server=Worker_server, Swarmcoloum_info=Swarm_info, Swarmcoloum__Manager=Swarm_Manager, Swarmcoloum__Worker=Swarm_Worker,swarmtitle='Swarm info',mangertitle='Manager Details',workertitle='Worker Details',)


@app.route('/deletedockerswarm',methods=['POST'])
def deletedockerswarm():
    dockerswarmList = request.get_json()
    print dockerswarmList
    print type(dockerswarmList)
    # Based on these values we will delete backend database rows..
    for swarm in dockerswarmList:
        deleteswarmdata(swarm)
    json = request.get_json()
    print json
    print type(json)

    datadict, dbcolumns = getdockerswarmdata()
    dbdata=sortdictolist(datadict,dbcolumns)
    return render_template('viewdockerswarm.html',dbdata=dbdata,dbcolumns=dbcolumns,title="DockerSwarm Clusters")
    #return render_template('viewdockerswarm.html')


@app.route('/vizualizer',methods=['GET', 'POST'])
def vizualizer():
    SwarmDict = getswarmdict(8080)
    return render_template('vizualizer.html',SwarmDict=SwarmDict)

## Errors
@app.errorhandler(403)
def not_found_error(error):
    return render_template('page_403.html'), 403

@app.errorhandler(404)
def not_found_error(error):
    return render_template('page_404.html'), 404

@app.errorhandler(500)
def internal_error(error):
    return render_template('page_500.html'), 500

# General methods
# This is moved to utils we can safely remove after testing..
def make_kv_pair(params):
    x = ' '
    kv_pairs = []
    for k, v in ast.literal_eval(json.dumps(params)).iteritems():
        kv = {
            "{0}".format("ParameterKey"): k,
            "{0}".format("ParameterValue"): v,
        }
        use_previous = False
        if use_previous != None:
            kv['UsePreviousValue'] = use_previous

        kv_pairs.append(kv)
    print kv_pairs
    return kv_pairs

# Getting Template Details
# This can be safely removed after testing..
def get_json(url, data_obj=None):
    try:
        url_final = "{0}".format(url)
        if data_obj:
            querystring = urllib.urlencode(data_obj)
            url_final = "{0}?{1}".format(url, querystring)

        get_headers = {'Content-Type': 'application/json'}
        req = urllib2.Request(url_final, headers=get_headers)
        response = urllib2.urlopen(req)
        json_response = response.read()
        #print "Sigma : json_response ", json_response
        return json.loads(json_response)
    except urllib2.HTTPError as e:
        print e
        return None
